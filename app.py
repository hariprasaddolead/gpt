import logging
import json
import traceback
from functools import wraps
from os import environ

import requests
import rollbar
from chalice import Response, Chalice, ConvertToMiddleware
from chalicelib.utils import (MissingMandatoryFieldsError,
                              ValueNotMappedError,
                              FieldNotComputedError, build_response)

#######################################
# AUTOGENERATED STUFF. DO NOT CHANGE. #
#######################################
app = Chalice(app_name='plug_freewebhelp')

if rollbar._initialized is False and 'rollbar_token_id' in environ:  # noqa
    rollbar.init(
        environ['rollbar_token_id'],
        environment=environ.get('rollbar_environment', 'test'))
    app.register_middleware(ConvertToMiddleware(rollbar.lambda_function), 'all')


def _get_redis_client():
    from redis import StrictRedis
    return StrictRedis.from_url(environ['redis_status_store_url'])


def __redis_key(lead_id, mode):
    return f"lead_status_{app.app_name}_{mode}_{lead_id}"


def store_in_redis(result, mode, ttl=10*60, keep_ttl=False):
    lead_id = get_json_body().get('lead_id')
    try:
        if not lead_id:
            return
        client = _get_redis_client()
        result = json.dumps(result).encode('utf-8')
        if keep_ttl:
            ttl = client.ttl(__redis_key(lead_id, mode)) or ttl
        client.setex(__redis_key(lead_id, mode), ttl, result)
    except Exception:
        logger.exception("Could not store the result for lead %s", lead_id)


def get_from_redis(lead_id, mode):
    try:
        client = _get_redis_client()
        result = client.get(__redis_key(lead_id, mode))
        if result:
            return json.loads(result.decode())
    except Exception:
        logger.exception("Could not get the cached result for lead %s", lead_id)


def store_results(mode):
    def store(f):
        @wraps(f)
        def wrapper(*args, **kwds):
            response = f(*args, **kwds)
            result = response.to_dict()
            store_in_redis(result, mode)
            return response
        return wrapper
    return store


logger = app.log
logger.setLevel(logging.INFO)


###########################
# END OF PROTECTED BLOCK. #
###########################

MANDATORY_MAPPING_FIELDS = {'Nom_Titulaire', 'Prenom_Titulaire', 'Tel_Mobile_Titulaire', 'Numero_Voie_Adresse_Titulaire', 'Nom_Voie_Adresse_Titulaire', 'Code_Postal_Adresse_Titulaire', 'Ville_Adresse_Titulaire' }
MANDATORY_COMPUTED_FIELDS = set()


def get_proxy():
    proxy = environ.get('api_proxy')
    if proxy:
        return {
            'http': proxy,
            'https': proxy
        }
    return None


def get_json_body():
    return app.current_request.json_body


def translate_lead(lead):
    """Do not try except when get send url.
       Then exception will be raised during _make_request call

       If needed, all fields are in the lead['fields'] object.
    """
    data = {}
    merge_customer_fields_mapping(data, lead)
    data['ID_Traitement'] = lead['lead_id']
    data['Civilite_Titulaire'] = ''
    data['Complement_Adresse_Titulaire'] = ''
    data['Complement_Adresse_2_Titulaire'] = ''
    return data


def merge_customer_fields_mapping(data, lead):
    customer_fields_mapping = lead.get('customer_fields_mapping')
    if not customer_fields_mapping:
        return
    customer_data = {}
    for reference_field, customer_mapping in customer_fields_mapping.items():
        if customer_mapping['customer_value']:
            input_id = customer_mapping['customer_key']
            input_value = customer_mapping['customer_value']
            customer_data[input_id] = input_value

    missing_fields = MANDATORY_MAPPING_FIELDS - set(customer_data)
    if missing_fields:
        raise MissingMandatoryFieldsError(missing_fields=missing_fields)
    data.update(customer_data)


def interpret_result(result, request_details=None):
    """
    This example parse a JSON result.

    :param result: requests Response object
    :param request_details: Payload sent to customer
    """
    try:
        json_return = result.json()
    except ValueError:
        json_return = {'raw': result.text}
    http_status_code = result.status_code
    json_return['http_status_code'] = http_status_code
    request = result.request

    accepted = 200 <= http_status_code < 300
    response = {
        'request_details': {
            'url': request.url,
            'headers': dict(request.headers),
            'method': request.method,
            'json': request_details or {}
        },
        'response_details': json_return,
    }
    if accepted:  # Success
        return_status_code = 200
    elif 'Message' in json_return:
        response['error_message'] = json_return['Message']
        if 'Records' in json_return and json_return['Records'][0]=={}:  # Empty lead
            return_status_code = 400
        elif 'duplicate' in json_return['Message'].lower():  # Duplicate lead
            return_status_code = 409
        else:
            return_status_code = 406
    else:  # General cases
        return_status_code = 406

    return response, return_status_code


def sanity_check(lead):
    missing_fields = MANDATORY_COMPUTED_FIELDS - set(lead.keys())
    if missing_fields:
        raise FieldNotComputedError(
                field=', '.join(sorted(missing_fields)), lead=lead)


def get_translated_lead():
    raw_lead = get_json_body()
    try:
        lead = translate_lead(lead=raw_lead)
        sanity_check(lead)
        return lead
    except (MissingMandatoryFieldsError,
            ValueNotMappedError,
            FieldNotComputedError) as ex:
        return build_response(ex.error_body, status_code=400)
    except KeyError as ex:
        return build_response({
                "error_message": "KeyError: {}".format(ex),
                "error": traceback.format_exc().splitlines()
            }, status_code=400)

def get_token(url,username, password):
    params = {
        'UserName': username,
        'Password': password
    }
    try:
        #import ipdb; ipdb.set_trace()
        token_response = requests.post(url.format('Authenticate'),
                                       json=params)
    except KeyError as ex:
        return Response(
            body=json.dumps({
                "error_message": "KeyError: {}".format(ex),
                "error": traceback.format_exc().splitlines()
            }),
            status_code=401,
            headers={'Content-Type': 'application/json'}
        )
    return token_response

def interpret_result_token(result, request_details=None):
    try:
        json_return = result.json()
    except ValueError:
        json_return = {'raw': result.text}
    http_status_code = result.status_code
    response = {}
    if http_status_code == 200:
        response['response_details'] = json_return
    else:
        http_status_code = 401
    return response, http_status_code

@app.route('/ping', methods=['POST'])
@store_results('ping')
def ping_customer():
    """
    Ping a customer with partial lead data to ask it if the lead
    is acceptable or not (and thus we won't send it the whole data).
    if the customer does not support ping feature, just return 200.

    Ex: used for geographic targeting.

    :returns: json response
    Status code are :
     * 200 (OK) for acceptable lead
     * 406 (NotAcceptable) for rejected lead.
    """
    return build_response({"result": "accepted"})


@app.route('/send', methods=['POST'])
@store_results('send')
def send_lead():
    """
    Send the received lead to the customer, and return the result of the operation.
    If provided by the customer, the response MUST contains the lead_id in the customer system.

    :return: json response
        Status code between 200 and 300 are considered as success.
        Please use preferably 200, 201 or 202.
        Please read the documentation for the error codes.
    """
    result = get_translated_lead()
    if isinstance(result, Response):
        return result
    lead = result

    logger.debug('Lead: %s', lead)

    token_response = get_token(environ['customer_api_url'],environ['username'], environ['password'])
    response_token_json, response_token_status_code = interpret_result_token(token_response)
    url = environ['customer_api_url'].format('ClientRecords')

    if response_token_status_code != 200:
        return Response(body=json.dumps(response_token_json),
                        status_code=response_token_status_code,
                        headers={'Content-Type': 'application/json'})
    token = token_response.json()
    result = requests.post(url,
                           json=lead,
                           headers=token)
    response_json, response_status_code = interpret_result(result, lead)

    return build_response(response_json, status_code=response_status_code)


@app.route('/status/{lead_id}')
@app.route('/status/{lead_id}/{mode}')
def get_lead_status(lead_id, mode='send'):
    try:
        client = _get_redis_client()
        result = client.get(f"lead_status_{mode}_{lead_id}")
        if result:
            response = json.loads(result.decode('utf_8'))
            return build_response(response['body'], status_code=response['statusCode'])
        return build_response({'Error': 'Processing not finished'},
                              status_code=504)
    except Exception:
        build_response({'Error': 'Not processable'},
                       status_code=504)